/*
Copyright IBM Corporation 2020

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package filesystem

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/go-resty/resty/v2"
	"github.com/konveyor/move2kube-api/cmd/version"
	"github.com/konveyor/move2kube-api/internal/common"
	"github.com/konveyor/move2kube-api/internal/types"
	"github.com/mholt/archiver/v3"
	"github.com/phayes/freeport"
	"github.com/sirupsen/logrus"
	"github.com/spf13/cast"
	"gopkg.in/yaml.v3"
)

const (
	// PROJECT_INPUTS_DIR is the directory where project inputs are stored
	PROJECT_INPUTS_DIR = "inputs"
	// PROJECT_OUTPUTS_DIR is the directory where project outputs are stored
	PROJECT_OUTPUTS_DIR = "outputs"
	// ARCHIVES_DIR is the directory where the archive files for project inputs are stored
	ARCHIVES_DIR = "archives"
	// EXPANDED_DIR is the directory where the archive files for project inputs are expanded and stored
	EXPANDED_DIR = "expanded"
	// SOURCES_DIR is the directory where the sources directory project inputs are stored
	SOURCES_DIR = string(types.ProjectInputSources)
	// CUSTOMIZATIONS_DIR is the directory where the customizations directory project inputs are stored
	CUSTOMIZATIONS_DIR = string(types.ProjectInputCustomizations)
	// CONFIGS_DIR is the directory where the configs files project inputs are stored
	CONFIGS_DIR = string(types.ProjectInputConfigs)
	// M2K_PLAN_FILENAME is the name of the plan file generated by Move2Kube CLI
	M2K_PLAN_FILENAME = common.APP_NAME_SHORT + ".plan"
	// M2K_QA_SERVER_METADATA_FILE is the name of the file containing the QA server metadata
	M2K_QA_SERVER_METADATA_FILE = common.APP_NAME_SHORT + ".qaserver"
	// M2K_PLAN_PROGRESS_SERVER_METADATA_FILE is the name of the file containing the plan progress server metadata
	M2K_PLAN_PROGRESS_SERVER_METADATA_FILE = common.APP_NAME_SHORT + ".planprogressserver"
	// M2K_CLI_LOG_FILE is the name of the log file that the CLI writes to
	M2K_CLI_LOG_FILE = common.APP_NAME_SHORT + "cli.log"
	// PROJECT_METADATA_FILE is the name of the file containing the project metadata
	PROJECT_METADATA_FILE = "metadata"
	// DEFAULT_DIRECTORY_PERMISSIONS is the default permissions used when creating new directories
	DEFAULT_DIRECTORY_PERMISSIONS os.FileMode = 0775
	// DEFAULT_FILE_PERMISSIONS is the default permissions used when creating new files
	DEFAULT_FILE_PERMISSIONS os.FileMode = 0660
)

var (
	// VALID_ARCHIVE_EXTS is the list of archive formats that are supported
	VALID_ARCHIVE_EXTS = []string{".zip", ".tar", ".tgz", ".gz"}
	// LOG_LEVEL_REGEXP is the regexp used to capture the loglevel from the CLI output
	LOG_LEVEL_REGEXP = regexp.MustCompile(`level=([a-z]+) `)
	// TIMESTAMP_REGEXP is the regexp used to replace the the timestamp in the CLI output with a different message
	TIMESTAMP_REGEXP = regexp.MustCompile(`time="\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(Z|\+\d{2}:\d{2})"`)
)

/*
Workspace Folder Structure
--------------------------
We make a copy of the entire source and config folders whenever a new run is triggered (by clicking the Transform button)
to avoid race conditions with some user changing the source folder while a plan or transformation is in progress.

It also allows for resuming previous runs. We remove the output folder if it exists (while preserving the m2kqaconfig file).
NOTE: don't need to preserve the m2kqacache because we cannot provide it to the subsequent runs to resume. The qacache flag has been removed from the CLI.

This also allows for neat features like showing a diff of the folder structure between runs.
This architecture should support multiple pod restarts (even during planning/translation).

TODO: also need to figure out where to put the config files. Currently we are not accepting upload or use of config files.

data/
	metadata/
		workspaces/
			work-id-1.json
			work-id-2.json
	projects/
		project-id-1/
			metadata.json
			inputs/
				archives/
					sources/
						lang-plat.zip
						estore.tar.gz
					customizations/
						cust-1.zip
						cust-2.zip
				expanded/
					sources/
						lang-plat/
						estore/
						.m2kignore
					customizations/
						cust-1/
						cust-2/
					configs/
						config-1.yaml
						config-2.yaml
					m2k.planprogressserver
					m2k.plan
					m2kcli.log
			outputs/
				run-id-1/
					sources/
						lang-plat/
						estore/
						.m2kignore
					customizations/
						cust-1/
						cust-2/
					configs/
						config-1.yaml
						config-2.yaml
					m2k.qaserver
					m2k.plan
					m2kconfig.yaml
					m2kqacache.yaml
					m2kcli.log
					output/
					output.zip
				run-id-2/
*/

// FileSystem implements the IFileSystem interface and manages the workspace and project data in the filesystem
type FileSystem struct{}

// GetSupportInfo returns information useful for debugging.
// Returns the output of move2kube version -l
func (*FileSystem) GetSupportInfo() map[string]string {
	cmd := exec.Command("move2kube", "version", "-l")
	cliVersionBytes, err := cmd.Output()
	if err != nil {
		logrus.Errorf("Failed to get the move2kube CLI version information. Error: %q", err)
		return nil
	}
	info := map[string]string{}
	info["cli_version"] = string(cliVersionBytes)
	info["api_version"] = version.GetVersion(true)
	uiVersion := struct {
		Version      string `yaml:"version"`
		GitCommit    string `yaml:"gitCommit"`
		GitTreeState string `yaml:"gitTreeState"`
	}{}
	if val, ok := os.LookupEnv("MOVE2KUBE_UI_VERSION"); ok {
		uiVersion.Version = val
	}
	if val, ok := os.LookupEnv("MOVE2KUBE_UI_GIT_COMMIT_HASH"); ok {
		uiVersion.GitCommit = val
	}
	if val, ok := os.LookupEnv("MOVE2KUBE_UI_GIT_TREE_STATUS"); ok {
		uiVersion.GitTreeState = val
	}
	info["ui_version"] = "unknown"
	if uiVersionBytes, err := yaml.Marshal(uiVersion); err != nil {
		logrus.Errorf("failed to marshal the support info for the UI %+v to yaml. Error: %q", uiVersion, err)
	} else {
		info["ui_version"] = string(uiVersionBytes)
	}
	info["docker"] = "docker socket is mounted"
	if _, err := os.Stat("/var/run/docker.sock"); err != nil {
		if os.IsNotExist(err) {
			info["docker"] = "docker socket is not mounted"
		} else {
			info["docker"] = fmt.Sprintf("docker socket error: %q", err)
		}
	}
	return info
}

// Download returns the app binary
func (*FileSystem) Download() (io.Reader, string, error) {
	path, err := exec.LookPath(common.APP_NAME)
	if err != nil {
		return nil, "", fmt.Errorf("unable to find the app executable named '%s' . Error: %q", common.APP_NAME, err)
	}
	f, err := os.Open(path)
	if err != nil {
		return nil, "", fmt.Errorf("failed to open the file at path %s . Error: %q", path, err)
	}
	return f, filepath.Base(path), nil
}

// ListWorkspaceIds returns the list of workspace Ids
func (fs *FileSystem) ListWorkspaceIds() ([]string, error) {
	workMetadataDir := filepath.Join(common.Config.DataDir, common.METADATAS_DIR, common.WORKSPACE_METADATAS_DIR)
	fInfos, err := os.ReadDir(workMetadataDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read the workspace metadata directory at path %s . Error: %q", workMetadataDir, err)
	}
	workspaceIds := []string{}
	for _, fInfo := range fInfos {
		workspaceIds = append(workspaceIds, fInfo.Name())
	}
	return workspaceIds, nil
}

// ListWorkspaces returns the list of workspaces
func (fs *FileSystem) ListWorkspaces(workspaceIds []string) ([]types.Workspace, error) {
	if workspaceIds == nil {
		var err error
		workspaceIds, err = fs.ListWorkspaceIds()
		if err != nil {
			return nil, fmt.Errorf("failed to list the workspace ids. Error: %q", err)
		}
	}
	workspaces := []types.Workspace{}
	for _, workspaceId := range workspaceIds {
		workspace, err := fs.ReadWorkspace(workspaceId)
		if err != nil {
			logrus.Errorf("failed to read the workspace with id: %s . Error: %q", workspaceId, err)
			continue
		}
		workspaces = append(workspaces, workspace)
	}
	return workspaces, nil
}

// CreateWorkspace creates a new workspace
func (*FileSystem) CreateWorkspace(workspace types.Workspace) error {
	metaFilePath := filepath.Join(common.Config.DataDir, common.METADATAS_DIR, common.WORKSPACE_METADATAS_DIR, workspace.Id)
	if _, err := os.Stat(metaFilePath); err == nil {
		return types.ErrorIdAlreadyInUse{Id: workspace.Id}
	}
	if err := WriteJSON(metaFilePath, workspace); err != nil {
		return fmt.Errorf("failed to write the workspace metadata to the file at path %s . Error: %q", metaFilePath, err)
	}
	return nil
}

// ReadWorkspace reads an existing workspace
func (fs *FileSystem) ReadWorkspace(workspaceId string) (types.Workspace, error) {
	work := types.Workspace{}
	workMetaFilePath := filepath.Join(common.Config.DataDir, common.METADATAS_DIR, common.WORKSPACE_METADATAS_DIR, workspaceId)
	if err := ReadJSON(workMetaFilePath, &work); err != nil {
		if os.IsNotExist(err) {
			return work, types.ErrorDoesNotExist{Id: workspaceId}
		}
		return work, fmt.Errorf("failed to read the workspace metadata file at path %s . Error: %q", workMetaFilePath, err)
	}
	return work, nil
}

// UpdateWorkspace updates an existing workspace
func (fs *FileSystem) UpdateWorkspace(workspace types.Workspace) error {
	workMetaFilePath := filepath.Join(common.Config.DataDir, common.METADATAS_DIR, common.WORKSPACE_METADATAS_DIR, workspace.Id)
	if _, err := fs.ReadWorkspace(workspace.Id); err != nil {
		return err
	}
	if err := WriteJSON(workMetaFilePath, workspace); err != nil {
		return fmt.Errorf("failed to write the workspace metadata to the file at path %s . Error: %q", workMetaFilePath, err)
	}
	return nil
}

// DeleteWorkspace deletes an existing workspace
func (fs *FileSystem) DeleteWorkspace(workspaceId string) error {
	work, err := fs.ReadWorkspace(workspaceId)
	if err != nil {
		return err
	}
	workMetaFilePath := filepath.Join(common.Config.DataDir, common.METADATAS_DIR, common.WORKSPACE_METADATAS_DIR, workspaceId)
	if err := os.RemoveAll(workMetaFilePath); err != nil {
		return fmt.Errorf("failed to remove the workspace metadata file at path %s . Error: %q", workMetaFilePath, err)
	}
	for _, projectId := range work.ProjectIds {
		projectDir := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId)
		if err := os.RemoveAll(projectDir); err != nil {
			logrus.Errorf("failed to remove the project %s in the workspace %s at the path %s . Error: %q", projectId, workspaceId, projectDir, err)
			continue
		}
	}
	return nil
}

// ListProjects returns the list of projects in the workspace
func (fs *FileSystem) ListProjects(workspaceId string) ([]types.Project, error) {
	work, err := fs.ReadWorkspace(workspaceId)
	if err != nil {
		return nil, err
	}
	projects := []types.Project{}
	for _, projectId := range work.ProjectIds {
		project, err := fs.ReadProject(workspaceId, projectId)
		if err != nil {
			logrus.Errorf("failed to read the project with id: %s . Error: %q", projectId, err)
			continue
		}
		projects = append(projects, project)
	}
	return projects, nil
}

// CreateProject creates a new project in the filesystem
func (fs *FileSystem) CreateProject(workspaceId string, project types.Project) error {
	work, err := fs.ReadWorkspace(workspaceId)
	if err != nil {
		return err
	}
	if common.IsStringPresent(work.ProjectIds, project.Id) {
		return types.ErrorIdAlreadyInUse{Id: project.Id}
	}
	logrus.Debugf("creating a new project: %+v in the workspace with id: %s", project, workspaceId)
	projDir := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, project.Id)
	if err := os.MkdirAll(projDir, DEFAULT_DIRECTORY_PERMISSIONS); err != nil {
		return fmt.Errorf("failed to make the project directory at path %s . Error: %q", projDir, err)
	}
	metadataFilePath := filepath.Join(projDir, PROJECT_METADATA_FILE)
	if err := WriteJSON(metadataFilePath, project); err != nil {
		return fmt.Errorf("failed to write the project metadata to file at path %s . Error: %q", metadataFilePath, err)
	}
	work.ProjectIds = append(work.ProjectIds, project.Id)
	if err := fs.UpdateWorkspace(work); err != nil {
		return fmt.Errorf("failed to update the workspace with id: %s . Error: %q", workspaceId, err)
	}
	return nil
}

// ReadProject returns the metadata about a project
func (fs *FileSystem) ReadProject(workspaceId string, projectId string) (types.Project, error) {
	project := types.Project{}
	work, err := fs.ReadWorkspace(workspaceId)
	if err != nil {
		return project, err
	}
	if !common.IsStringPresent(work.ProjectIds, projectId) {
		return project, types.ErrorDoesNotExist{Id: projectId}
	}
	metadataFilePath := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_METADATA_FILE)
	if err := ReadJSON(metadataFilePath, &project); err != nil {
		return project, fmt.Errorf("failed to read the project from the metadata file at path %s . Error: %q", metadataFilePath, err)
	}
	if project.Inputs == nil {
		project.Inputs = map[string]types.ProjectInput{}
	}
	if project.Outputs == nil {
		project.Outputs = map[string]types.ProjectOutput{}
	}
	if project.Status == nil {
		project.Status = map[types.ProjectStatus]bool{}
	}
	logrus.Debugf("ReadProject project: %+v", project)
	return project, nil
}

// UpdateProject updates a new project in the filesystem
func (fs *FileSystem) UpdateProject(workspaceId string, project types.Project) error {
	work, err := fs.ReadWorkspace(workspaceId)
	if err != nil {
		return err
	}
	if !common.IsStringPresent(work.ProjectIds, project.Id) {
		return types.ErrorDoesNotExist{Id: project.Id}
	}
	logrus.Debugf("updating an existing project: %+v in the workspace with id: %s", project, workspaceId)
	metadataFilePath := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, project.Id, PROJECT_METADATA_FILE)
	if err := WriteJSON(metadataFilePath, project); err != nil {
		return fmt.Errorf("failed to write the project metadata to file at path %s . Error: %q", metadataFilePath, err)
	}
	return nil
}

// DeleteProject deletes an project from the filesysem
func (fs *FileSystem) DeleteProject(workspaceId string, projectId string) error {
	work, err := fs.ReadWorkspace(workspaceId)
	if err != nil {
		return err
	}
	if !common.IsStringPresent(work.ProjectIds, projectId) {
		return types.ErrorDoesNotExist{Id: projectId}
	}
	projDir := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId)
	if err := os.RemoveAll(projDir); err != nil {
		return fmt.Errorf("failed to remove the project at path %s . Error: %q", projDir, err)
	}
	filtered := []string{}
	for _, pid := range work.ProjectIds {
		if pid == projectId {
			continue
		}
		filtered = append(filtered, pid)
	}
	work.ProjectIds = filtered
	if err := fs.UpdateWorkspace(work); err != nil {
		return fmt.Errorf("failed to update the workspace with id: %s . Error: %q", workspaceId, err)
	}
	return nil
}

// CreateProjectInput creates an input for the project in the filesystem
func (fs *FileSystem) CreateProjectInput(workspaceId, projectId string, projInput types.ProjectInput, file io.Reader) error {
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return err
	}
	if _, ok := project.Inputs[projInput.Id]; ok {
		return types.ErrorIdAlreadyInUse{Id: projInput.Id}
	}
	for _, pi := range project.Inputs {
		if pi.NormalizedName == projInput.NormalizedName {
			reason := fmt.Sprintf("You have already uploaded an input with the filename '%s'. Please pick a different one.", projInput.NormalizedName)
			logrus.Debugf(reason)
			return types.ErrorValidation{Reason: reason}
		}
	}
	project.Inputs[projInput.Id] = projInput
	lastDir := ""
	if projInput.Type == types.ProjectInputSources {
		project.Status[types.ProjectStatusInputSources] = true
		lastDir = SOURCES_DIR
	} else if projInput.Type == types.ProjectInputCustomizations {
		project.Status[types.ProjectStatusInputCustomizations] = true
		lastDir = CUSTOMIZATIONS_DIR
	} else if projInput.Type == types.ProjectInputConfigs {
		project.Status[types.ProjectStatusInputConfigs] = true
		lastDir = CONFIGS_DIR
	} else {
		return types.ErrorValidation{Reason: fmt.Sprintf("invalid project input type: %s", projInput.Type)}
	}
	logrus.Debugf("creating a new input for the project %s with type %s and filename %s", projectId, projInput.Type, projInput.Name)
	projInputsDir := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_INPUTS_DIR)
	archDir := filepath.Join(projInputsDir, ARCHIVES_DIR, lastDir)
	archExpDir := filepath.Join(projInputsDir, EXPANDED_DIR, lastDir)
	archivePath := filepath.Join(archDir, projInput.NormalizedName)
	archiveExpandedPath := filepath.Join(archExpDir, projInput.NormalizedName)
	if err := os.RemoveAll(archivePath); err != nil {
		return fmt.Errorf("failed to remove the archive at path %s . Error: %q", archivePath, err)
	}
	if err := os.RemoveAll(archiveExpandedPath); err != nil {
		return fmt.Errorf("failed to remove the archive expanded directory at the path %s . Error: %q", archiveExpandedPath, err)
	}
	if projInput.Type == types.ProjectInputConfigs {
		if err := os.MkdirAll(archExpDir, DEFAULT_DIRECTORY_PERMISSIONS); err != nil {
			return fmt.Errorf("failed to create a directory at the path %s . Error: %q", archExpDir, err)
		}
		// write the config file they uploaded
		f, err := os.OpenFile(archiveExpandedPath, os.O_WRONLY|os.O_CREATE, DEFAULT_FILE_PERMISSIONS)
		if err != nil {
			return fmt.Errorf("failed to write the config file to the path %s . Error: %q", archivePath, err)
		}
		defer f.Close()
		if _, err := io.Copy(f, file); err != nil {
			return fmt.Errorf("failed to receive and write the config file to the path %s completely. Error: %q", archiveExpandedPath, err)
		}
		if err := fs.UpdateProject(workspaceId, project); err != nil {
			return fmt.Errorf("failed to update the project with id: %s . Error: %q", projectId, err)
		}
		return nil
	}
	if err := os.MkdirAll(archDir, DEFAULT_DIRECTORY_PERMISSIONS); err != nil {
		return fmt.Errorf("failed to create the archive directory at the path %s . Error: %q", archDir, err)
	}
	if err := putM2KIgnore(archExpDir); err != nil { // also creates the directory if it doesn't exist, overwrites if it does exist
		return fmt.Errorf("failed to create a m2kignore file at the path %s . Error: %q", archExpDir, err)
	}
	if err := putM2KIgnore(archiveExpandedPath); err != nil { // TODO: is this necessary?
		return fmt.Errorf("failed to create a m2kignore file at the path %s . Error: %q", archiveExpandedPath, err)
	}
	// write the archive they uploaded
	f, err := os.OpenFile(archivePath, os.O_WRONLY|os.O_CREATE, DEFAULT_FILE_PERMISSIONS)
	if err != nil {
		return fmt.Errorf("failed to write the archive to the path %s . Error: %q", archivePath, err)
	}
	defer f.Close()
	if _, err := io.Copy(f, file); err != nil {
		return fmt.Errorf("failed to receive the archive file %s completely. Error: %q", projInput.Name, err)
	}
	// expand the archive
	if err := archiver.Unarchive(archivePath, archiveExpandedPath); err != nil {
		filename := projInput.Name
		if filepath.Ext(filename) == ".zip" {
			if err := archiver.NewZip().Unarchive(archivePath, archiveExpandedPath); err != nil {
				return fmt.Errorf("failed to expand the zip archive at path %s to the path %s . Error: %q", archivePath, archiveExpandedPath, err)
			}
		} else if filepath.Ext(filename) == ".tar" {
			if err := archiver.NewTar().Unarchive(archivePath, archiveExpandedPath); err != nil {
				return fmt.Errorf("failed to expand the tar archive at path %s to the path %s . Error: %q", archivePath, archiveExpandedPath, err)
			}
		} else if filepath.Ext(filename) == ".tgz" || strings.HasSuffix(filename, ".tar.gz") {
			if err := archiver.NewTarGz().Unarchive(archivePath, archiveExpandedPath); err != nil {
				return fmt.Errorf("failed to expand the tar.gz archive at path %s to the path %s . Error: %q", archivePath, archiveExpandedPath, err)
			}
		} else {
			return fmt.Errorf("the archive at path %s is not in a supported format. Please use one of the supported formats: %+v", archivePath, VALID_ARCHIVE_EXTS)
		}
	}
	if err := fs.UpdateProject(workspaceId, project); err != nil {
		return fmt.Errorf("failed to update the project with id: %s . Error: %q", projectId, err)
	}
	return nil
}

// ReadProjectInput returns a project input
func (fs *FileSystem) ReadProjectInput(workspaceId, projectId, projInputId string) (projInput types.ProjectInput, file io.Reader, err error) {
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return types.ProjectInput{}, nil, err
	}
	projInput, ok := project.Inputs[projInputId]
	if !ok {
		return projInput, nil, types.ErrorDoesNotExist{Id: projInputId}
	}
	projInputsDir := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_INPUTS_DIR)
	archivePath := ""
	if projInput.Type == types.ProjectInputSources {
		archivePath = filepath.Join(projInputsDir, ARCHIVES_DIR, SOURCES_DIR, projInput.NormalizedName)
	} else if projInput.Type == types.ProjectInputCustomizations {
		archivePath = filepath.Join(projInputsDir, ARCHIVES_DIR, CUSTOMIZATIONS_DIR, projInput.NormalizedName)
	} else if projInput.Type == types.ProjectInputConfigs {
		archivePath = filepath.Join(projInputsDir, EXPANDED_DIR, CONFIGS_DIR, projInput.NormalizedName)
	} else {
		return projInput, nil, types.ErrorValidation{Reason: fmt.Sprintf("invalid project input type: %s", projInput.Type)}
	}
	f, err := os.Open(archivePath)
	if err != nil {
		return projInput, nil, fmt.Errorf("failed to open the project input with id: %s at path %s . Error: %q", projInputId, archivePath, err)
	}
	return projInput, f, nil
}

// DeleteProjectInput deletes the project input
func (fs *FileSystem) DeleteProjectInput(workspaceId, projectId, projInputId string) error {
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return err
	}
	projInput, ok := project.Inputs[projInputId]
	if !ok {
		return types.ErrorDoesNotExist{Id: projInputId}
	}
	projInputsDir := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_INPUTS_DIR)
	archivePath := ""
	archiveExpandedPath := ""
	if projInput.Type == types.ProjectInputSources {
		archivePath = filepath.Join(projInputsDir, ARCHIVES_DIR, SOURCES_DIR, projInput.NormalizedName)
		archiveExpandedPath = filepath.Join(projInputsDir, EXPANDED_DIR, SOURCES_DIR, projInput.NormalizedName)
	} else if projInput.Type == types.ProjectInputCustomizations {
		archivePath = filepath.Join(projInputsDir, ARCHIVES_DIR, CUSTOMIZATIONS_DIR, projInput.NormalizedName)
		archiveExpandedPath = filepath.Join(projInputsDir, EXPANDED_DIR, CUSTOMIZATIONS_DIR, projInput.NormalizedName)
	} else if projInput.Type == types.ProjectInputConfigs {
		archiveExpandedPath = filepath.Join(projInputsDir, EXPANDED_DIR, CONFIGS_DIR, projInput.NormalizedName)
	} else {
		return types.ErrorValidation{Reason: fmt.Sprintf("invalid project input type: %s", projInput.Type)}
	}
	if projInput.Type != types.ProjectInputConfigs {
		if err := os.RemoveAll(archivePath); err != nil {
			return fmt.Errorf("failed to delete the archive file with id: %s at path %s . Error: %q", projInputId, archivePath, err)
		}
	}
	if err := os.RemoveAll(archiveExpandedPath); err != nil {
		return fmt.Errorf("failed to delete the expanded archive directory/config file at path %s . Error: %q", archiveExpandedPath, err)
	}
	delete(project.Inputs, projInputId)
	found := false
	for _, projInp := range project.Inputs {
		if projInp.Type == projInput.Type {
			found = true
			break
		}
	}
	if !found {
		if projInput.Type == types.ProjectInputSources {
			project.Status[types.ProjectStatusInputSources] = false
		} else if projInput.Type == types.ProjectInputCustomizations {
			project.Status[types.ProjectStatusInputCustomizations] = false
		} else {
			project.Status[types.ProjectStatusInputConfigs] = false
		}
	}
	if err := fs.UpdateProject(workspaceId, project); err != nil {
		return fmt.Errorf("failed to update project with id: %s . Error: %q", projectId, err)
	}
	return nil
}

// StartPlanning starts the generation of a plan for a project.
// If plan generation is ongoing it will return an error.
func (fs *FileSystem) StartPlanning(workspaceId, projectId string, debugMode bool) error {
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return err
	}
	// check lock
	if project.Status[types.ProjectStatusPlanning] {
		return types.ErrorOngoing{Id: projectId}
	}
	if !project.Status[types.ProjectStatusInputSources] {
		return types.ErrorValidation{Reason: "the project has no input sources"}
	}
	// acquire lock
	project.Status[types.ProjectStatusPlanning] = true
	if err := fs.UpdateProject(workspaceId, project); err != nil {
		return fmt.Errorf("failed to update the project with id %s . Error: %q", projectId, err)
	}
	message := "Project: " + project.Id + ";"
	currentRunDir := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, project.Id, PROJECT_INPUTS_DIR, EXPANDED_DIR)
	currentRunSrcDir := filepath.Join(currentRunDir, SOURCES_DIR)
	currentRunCustDir := ""
	if project.Status[types.ProjectStatusInputCustomizations] {
		currentRunCustDir = filepath.Join(currentRunDir, CUSTOMIZATIONS_DIR)
	}
	var currentRunConfigPaths []string = nil
	if project.Status[types.ProjectStatusInputConfigs] {
		t1 := filepath.Join(currentRunDir, CONFIGS_DIR)
		currentRunConfigPaths, err = getConfigPaths(t1, project)
		if err != nil {
			return fmt.Errorf("failed to get the config paths from the directory %s . Error: %q", t1, err)
		}
	}
	// This file contains the metadata about a run (host and port of the QA engine's http server, etc.)
	planProgressServerMeta := types.QAServerMetadata{Host: getDNSHostName(), Debug: debugMode}
	if planProgressServerMeta.Host == "" {
		planProgressServerMeta.Host = "localhost"
	}
	planProgressServerMeta.Port, err = freeport.GetFreePort()
	if err != nil {
		return fmt.Errorf("failed to get a free port. Error: %q", err)
	}
	logrus.Debugf("plan progress server metadata %+v", planProgressServerMeta)
	planProgressServerMetaPath := filepath.Join(currentRunDir, M2K_PLAN_PROGRESS_SERVER_METADATA_FILE)
	if err := WriteJSON(planProgressServerMetaPath, planProgressServerMeta); err != nil {
		return fmt.Errorf("failed to write to the plan progress server metadata to the file at path %s . Error: %q", planProgressServerMetaPath, err)
	}
	// start plan generation
	go fs.runPlan(currentRunDir, currentRunConfigPaths, currentRunSrcDir, currentRunCustDir, currentRunDir, message, planProgressServerMeta.Port, workspaceId, projectId, debugMode)
	logrus.Infof("Planning started for the project with id %s", projectId)
	return nil
}

// ReadPlan returns the plan for a project
func (fs *FileSystem) ReadPlan(workspaceId, projectId string) (file io.Reader, err error) {
	logrus.Debugf("read the plan for project with id: %s", projectId)
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return nil, err
	}
	// check lock
	currentRunDir := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_INPUTS_DIR, EXPANDED_DIR)
	if project.Status[types.ProjectStatusPlanning] {
		planProgressServerMetaPath := filepath.Join(currentRunDir, M2K_PLAN_PROGRESS_SERVER_METADATA_FILE)
		meta := types.QAServerMetadata{}
		if err := ReadJSON(planProgressServerMetaPath, &meta); err != nil {
			logrus.Errorf("failed to read the plan progress. Error: %q", err)
			return nil, types.ErrorOngoing{Id: projectId}
		}
		proURL := fmt.Sprintf("http://%s:%d/progress", meta.Host, meta.Port)
		resp, err := resty.New().R().SetHeader("Accept", "application/json").Get(proURL)
		if err != nil {
			logrus.Errorf("failed to send a GET request to get the plan progress from the server at %s . Error: %q", proURL, err)
			return nil, types.ErrorOngoing{Id: projectId}
		}
		return bytes.NewBuffer(resp.Body()), types.ErrorOngoing{Id: projectId}
	}
	if !project.Status[types.ProjectStatusPlan] {
		return nil, types.ErrorDoesNotExist{Id: projectId}
	}
	planFilePath := filepath.Join(currentRunDir, M2K_PLAN_FILENAME)
	f, err := os.Open(planFilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to open the file at path %s . Error: %q", planFilePath, err)
	}
	return f, nil
}

// UpdatePlan updates the plan file for a project
func (fs *FileSystem) UpdatePlan(workspaceId, projectId string, plan io.Reader) error {
	logrus.Infof("Updating plan of %s", projectId)
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return err
	}
	if !project.Status[types.ProjectStatusPlan] {
		return types.ErrorValidation{Reason: "the project has no plan yet. Generate a plan first."}
	}
	// check lock
	if project.Status[types.ProjectStatusPlanning] {
		return types.ErrorOngoing{Id: projectId}
	}
	planBytes, err := ioutil.ReadAll(plan)
	if err != nil {
		return fmt.Errorf("failed to read the plan. Error: %q", err)
	}
	if _, err := validateAndProcessPlan(string(planBytes), false); err != nil {
		return types.ErrorValidation{Reason: fmt.Sprintf("plan validation failed. Error: %q", err)}
	}
	planFilePath := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_INPUTS_DIR, EXPANDED_DIR, M2K_PLAN_FILENAME)
	if err := ioutil.WriteFile(planFilePath, planBytes, DEFAULT_FILE_PERMISSIONS); err != nil {
		return fmt.Errorf("failed to write to the plan file at path %s . Error: %q", planFilePath, err)
	}
	logrus.Infof("Plan updated successfully")
	return nil
}

// DeletePlan deletes plan for a project
func (fs *FileSystem) DeletePlan(workspaceId, projectId string) error {
	logrus.Trace("DeletePlan start")
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return err
	}
	if !project.Status[types.ProjectStatusPlan] {
		return types.ErrorValidation{Reason: "the project has no plan yet. Generate a plan first."}
	}
	// check lock
	if project.Status[types.ProjectStatusPlanning] {
		// TODO: allow stopping ongoing plan generation
		return types.ErrorOngoing{Id: projectId}
	}
	planFilePath := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_INPUTS_DIR, EXPANDED_DIR, M2K_PLAN_FILENAME)
	if err := os.RemoveAll(planFilePath); err != nil {
		return fmt.Errorf("failed to delete the plan file at path %s . Error: %q", planFilePath, err)
	}
	project.Status[types.ProjectStatusPlan] = false
	if err := fs.UpdateProject(workspaceId, project); err != nil {
		return fmt.Errorf("failed to update the project with id %s . Error: %q", projectId, err)
	}
	logrus.Trace("DeletePlan end")
	return nil
}

// ResumeTransformation resumes a transformation that did not finish
func (fs *FileSystem) ResumeTransformation(workspaceId, projectId, projOutputId string, debugMode bool) error {
	logrus.Trace("ResumeTransformation start")
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return err
	}
	projOutput, ok := project.Outputs[projOutputId]
	if !ok {
		return types.ErrorDoesNotExist{Id: projOutputId}
	}
	if projOutput.Status == types.ProjectOutputStatusDone {
		logrus.Debugf("the transformation for output %s of project %s already finished", projOutputId, projectId)
		return nil
	}
	if projOutput.Status != types.ProjectOutputStatusInProgress {
		return fmt.Errorf("expected the project output to be in status '%s' . Actual: %+v", types.ProjectOutputStatusInProgress, projOutput)
	}
	currentRunDir := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_OUTPUTS_DIR, projOutputId)
	qaServerMetaPath := filepath.Join(currentRunDir, M2K_QA_SERVER_METADATA_FILE)
	qaServerMeta := types.QAServerMetadata{}
	if err := ReadJSON(qaServerMetaPath, &qaServerMeta); err != nil {
		logrus.Errorf("failed to read the qa server metadata file at the path %s . Error: %q", qaServerMetaPath, err)
		return err
	}
	if _, err := http.Get(fmt.Sprintf("http://%s:%d", qaServerMeta.Host, qaServerMeta.Port)); err == nil {
		return types.ErrorOngoing{Id: projOutputId}
	}
	// resume the transformation
	qaServerMeta.Host = getDNSHostName()
	if qaServerMeta.Host == "" {
		qaServerMeta.Host = "localhost"
	}
	qaServerMeta.Port, err = freeport.GetFreePort()
	if err != nil {
		return fmt.Errorf("failed to get a free port. Error: %q", err)
	}
	qaServerMeta.Debug = debugMode || qaServerMeta.Debug
	if err := WriteJSON(qaServerMetaPath, qaServerMeta); err != nil {
		return fmt.Errorf("failed to write to the qa server metadata to the file at path %s . Error: %q", qaServerMetaPath, err)
	}
	currentRunSrcDir := ""
	if project.Status[types.ProjectStatusInputSources] {
		currentRunSrcDir = filepath.Join(currentRunDir, SOURCES_DIR)
	}
	currentRunCustDir := ""
	if project.Status[types.ProjectStatusInputCustomizations] {
		currentRunCustDir = filepath.Join(currentRunDir, CUSTOMIZATIONS_DIR)
	}
	currentRunOutDir := filepath.Join(currentRunDir, "output")
	message := "Project: " + projectId + "; Output:" + projOutputId + ";"
	transformCh := make(chan error, 2)
	logrus.Infof("Resuming transformation for output %s of project %s", projOutputId, projectId)
	var currentRunConfigPaths []string = nil
	if project.Status[types.ProjectStatusInputConfigs] {
		t1 := filepath.Join(currentRunDir, CONFIGS_DIR)
		currentRunConfigPaths, err = getConfigPaths(t1, project)
		if err != nil {
			return fmt.Errorf("failed to get the config paths from the directory %s . Error: %q", t1, err)
		}
	}
	go fs.runTransform(currentRunDir, currentRunConfigPaths, currentRunSrcDir, currentRunCustDir, currentRunOutDir, message, qaServerMeta.Port, transformCh, workspaceId, projectId, projOutput, debugMode)
	logrus.Trace("ResumeTransformation end")
	return nil
}

// StartTransformation starts the transformation for a project.
func (fs *FileSystem) StartTransformation(workspaceId, projectId string, projOutput types.ProjectOutput, plan io.Reader, debugMode bool) error {
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return err
	}
	if _, ok := project.Outputs[projOutput.Id]; ok {
		return types.ErrorIdAlreadyInUse{Id: projOutput.Id}
	}
	if !project.Status[types.ProjectStatusInputSources] {
		return fmt.Errorf("the project has no input sources")
	}
	project.Outputs[projOutput.Id] = projOutput
	project.Status[types.ProjectStatusOutputs] = true
	if err := fs.UpdateProject(workspaceId, project); err != nil {
		return fmt.Errorf("failed to update the project with id %s . Error: %q", projectId, err)
	}
	projInputsDir := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_INPUTS_DIR)
	currentRunDir := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_OUTPUTS_DIR, projOutput.Id)
	if err := os.MkdirAll(currentRunDir, DEFAULT_DIRECTORY_PERMISSIONS); err != nil {
		return fmt.Errorf("failed to make the project output directory at path %s . Error: %q", currentRunDir, err)
	}
	var planBytes []byte
	if plan == nil {
		srcPlanPath := filepath.Join(projInputsDir, EXPANDED_DIR, M2K_PLAN_FILENAME)
		planBytes, err = ioutil.ReadFile(srcPlanPath)
		if err != nil {
			if os.IsNotExist(err) {
				return types.ErrorDoesNotExist{Id: "plan"}
			}
			return fmt.Errorf("failed to read the plan file at path %s . Error: %q", srcPlanPath, err)
		}
	} else {
		planBytes, err = ioutil.ReadAll(plan)
		if err != nil {
			return fmt.Errorf("failed to read the plan. Error: %q", err)
		}
	}
	planStr, err := validateAndProcessPlan(string(planBytes), true)
	if err != nil {
		return types.ErrorValidation{Reason: err.Error()}
	}
	planPath := filepath.Join(currentRunDir, M2K_PLAN_FILENAME)
	if err := ioutil.WriteFile(planPath, []byte(planStr), DEFAULT_FILE_PERMISSIONS); err != nil {
		return fmt.Errorf("failed to write the plan to a file at path %s . Error: %q", planPath, err)
	}
	// copy the source and customizations directories into the run directory
	srcPath := filepath.Join(projInputsDir, EXPANDED_DIR, SOURCES_DIR)
	currentRunSrcDir := filepath.Join(currentRunDir, SOURCES_DIR)
	if err := copyDir(srcPath, currentRunSrcDir); err != nil {
		return fmt.Errorf("failed to copy the source directory from %s to %s for the current run. Error: %q", srcPath, currentRunSrcDir, err)
	}
	currentRunCustDir := ""
	if project.Status[types.ProjectStatusInputCustomizations] {
		custPath := filepath.Join(projInputsDir, EXPANDED_DIR, CUSTOMIZATIONS_DIR)
		currentRunCustDir = filepath.Join(currentRunDir, CUSTOMIZATIONS_DIR)
		if err := copyDir(custPath, currentRunCustDir); err != nil {
			return fmt.Errorf("failed to copy the customizations directory from %s to %s for the current run. Error: %q", custPath, currentRunCustDir, err)
		}
	}
	var currentRunConfigPaths []string = nil
	if project.Status[types.ProjectStatusInputConfigs] {
		configsPath := filepath.Join(projInputsDir, EXPANDED_DIR, CONFIGS_DIR)
		t1 := filepath.Join(currentRunDir, CONFIGS_DIR)
		if err := copyDir(configsPath, t1); err != nil {
			return fmt.Errorf("failed to copy the customizations directory from %s to %s for the current run. Error: %q", configsPath, t1, err)
		}
		currentRunConfigPaths, err = getConfigPaths(t1, project)
		if err != nil {
			return fmt.Errorf("failed to get the config paths from the directory %s . Error: %q", t1, err)
		}
	}
	currentRunOutDir := filepath.Join(currentRunDir, "output")
	message := "Project: " + projectId + "; Output:" + projOutput.Id + ";"
	transformCh := make(chan error, 2)
	// This file contains the metadata about a run (host and port of the QA engine's http server, etc.)
	qaServerMeta := types.QAServerMetadata{Host: getDNSHostName(), Debug: debugMode}
	if qaServerMeta.Host == "" {
		qaServerMeta.Host = "localhost"
	}
	qaServerMeta.Port, err = freeport.GetFreePort()
	if err != nil {
		return fmt.Errorf("failed to get a free port. Error: %q", err)
	}
	logrus.Debugf("qa server metadata %+v", qaServerMeta)
	qaServerMetaPath := filepath.Join(currentRunDir, M2K_QA_SERVER_METADATA_FILE)
	if err := WriteJSON(qaServerMetaPath, qaServerMeta); err != nil {
		return fmt.Errorf("failed to write to the qa server metadata to the file at path %s . Error: %q", qaServerMetaPath, err)
	}
	// start the transformation
	go fs.runTransform(currentRunDir, currentRunConfigPaths, currentRunSrcDir, currentRunCustDir, currentRunOutDir, message, qaServerMeta.Port, transformCh, workspaceId, projectId, projOutput, debugMode)
	logrus.Infof("Waiting for QA engine to start for the output %s of the project %s", projOutput.Id, projectId)
	if err := <-transformCh; err != nil {
		return fmt.Errorf("failed to start the transformation and qa engine. Error: %q", err)
	}
	logrus.Infof("Transformation and QA engine has started for output %s of project %s at port %d", projOutput.Id, projectId, qaServerMeta.Port)
	return nil
}

// ReadProjectOutput returns the target artifacts for an application
func (fs *FileSystem) ReadProjectOutput(workspaceId, projectId, projOutputId string) (projOutput types.ProjectOutput, file io.Reader, err error) {
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return types.ProjectOutput{}, nil, err
	}
	projOutput, ok := project.Outputs[projOutputId]
	if !ok {
		return projOutput, nil, types.ErrorDoesNotExist{Id: projOutputId}
	}
	if projOutput.Status == types.ProjectOutputStatusInProgress {
		return projOutput, nil, types.ErrorOngoing{Id: projOutputId}
	}
	if projOutput.Status != types.ProjectOutputStatusDone {
		return projOutput, nil, types.ErrorDoesNotExist{Id: projOutputId}
	}
	projOutputPath := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_OUTPUTS_DIR, projOutputId, "output.zip")
	f, err := os.Open(projOutputPath)
	if err != nil {
		return projOutput, nil, fmt.Errorf("failed to read the project output file at path %s . Error: %q", projOutputPath, err)
	}
	return projOutput, f, nil
}

// DeleteProjectOutput deletes the project output
func (fs *FileSystem) DeleteProjectOutput(workspaceId, projectId, projOutputId string) error {
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return err
	}
	projOutput, ok := project.Outputs[projOutputId]
	if !ok {
		return types.ErrorDoesNotExist{Id: projOutputId}
	}
	if projOutput.Status == types.ProjectOutputStatusInProgress {
		// TODO: implement ability to cancel ongoing transformation
		return types.ErrorOngoing{Id: projOutputId}
	}
	qaServerMetaPath := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_OUTPUTS_DIR, projOutputId, M2K_QA_SERVER_METADATA_FILE)
	qaServerMetadata := types.QAServerMetadata{}
	if err := ReadJSON(qaServerMetaPath, &qaServerMetadata); err != nil {
		logrus.Errorf("deleting the output with id: %s even though we failed to read the qa server metadata file at path %s . Error: %q", projOutputId, qaServerMetaPath, err)
	}
	projOutputPath := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_OUTPUTS_DIR, projOutputId)
	if err := os.RemoveAll(projOutputPath); err != nil {
		return fmt.Errorf("failed to remove the project output with id: %s directory at path %s . Error: %q", projOutputId, projOutputPath, err)
	}
	delete(project.Outputs, projOutputId)
	if len(project.Outputs) == 0 {
		project.Status[types.ProjectStatusOutputs] = false
	}
	if err := fs.UpdateProject(workspaceId, project); err != nil {
		return fmt.Errorf("failed to update project id: %s . Error: %q", projectId, err)
	}
	return nil
}

// GetQuestion returns the current question for application which is in transformation phase.
// If there are no more questions, this will return "", nil.
func (fs *FileSystem) GetQuestion(workspaceId, projectId, projOutputId string) (problem string, err error) {
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return "", err
	}
	projOutput, ok := project.Outputs[projOutputId]
	if !ok {
		return "", types.ErrorDoesNotExist{Id: projOutputId}
	}
	if projOutput.Status == types.ProjectOutputStatusDone {
		logrus.Debugf("the transformation for output %s of project %s already finished", projOutputId, projectId)
		return "", nil
	}
	if projOutput.Status != types.ProjectOutputStatusInProgress {
		return "", fmt.Errorf("expected the project output to be in status '%s' . Actual: %+v", types.ProjectOutputStatusInProgress, projOutput)
	}
	qaServerMetaPath := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_OUTPUTS_DIR, projOutputId, M2K_QA_SERVER_METADATA_FILE)
	qaServerMetadata := types.QAServerMetadata{}
	if err := ReadJSON(qaServerMetaPath, &qaServerMetadata); err != nil {
		if os.IsNotExist(err) {
			return "", fmt.Errorf("the qa server metadata file at path %s is missing. Error: %q", qaServerMetaPath, err)
		}
		return "", fmt.Errorf("failed to read the qa server metadata at path %s . Error: %q", qaServerMetaPath, err)
	}
	quesURL := fmt.Sprintf("http://%s:%d/problems/current", qaServerMetadata.Host, qaServerMetadata.Port)
	logrus.Debugf("Getting the next question from the URL %s", quesURL)
	resp, err := http.Get(quesURL)
	checkErr(err)
	if err != nil {
		return "", fmt.Errorf("failed to send a GET request to the URL %s . Error: %q", quesURL, err)
	}
	if resp.StatusCode < 200 || resp.StatusCode > 299 {
		return "", fmt.Errorf("got an error response status code. Status: %s", resp.Status)
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read the response body. Error: %q", err)
	}
	question := string(respBodyBytes)
	if question == "" {
		logrus.Debugf("there are no more questions to get.")
		return "", nil
	}
	logrus.Debugf("got a new question: %s", question)
	return question, nil
}

// PostSolution posts the solution for the current question
func (fs *FileSystem) PostSolution(workspaceId, projectId, projOutputId, solution string) error {
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return err
	}
	projOutput, ok := project.Outputs[projOutputId]
	if !ok {
		return types.ErrorDoesNotExist{Id: projOutputId}
	}
	if projOutput.Status == types.ProjectOutputStatusDone {
		logrus.Debugf("the transformation for output %s of project %s already finished", projOutputId, projectId)
		return nil
	}
	if projOutput.Status != types.ProjectOutputStatusInProgress {
		return fmt.Errorf("expected the project output to be in status '%s' . Actual: %+v", types.ProjectOutputStatusInProgress, projOutput)
	}
	qaServerMetaPath := filepath.Join(common.Config.DataDir, common.PROJECTS_DIR, projectId, PROJECT_OUTPUTS_DIR, projOutputId, M2K_QA_SERVER_METADATA_FILE)
	qaServerMetadata := types.QAServerMetadata{}
	if err := ReadJSON(qaServerMetaPath, &qaServerMetadata); err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("the qa server metadata file at path %s is missing. Error: %q", qaServerMetaPath, err)
		}
		return fmt.Errorf("failed to read the qa server metadata at path %s . Error: %q", qaServerMetaPath, err)
	}
	quesURL := fmt.Sprintf("http://%s:%d/problems/current/solution", qaServerMetadata.Host, qaServerMetadata.Port)
	logrus.Debugf("Posting the solution to the URL %s", quesURL)
	resp, err := http.Post(quesURL, common.CONTENT_TYPE_JSON, bytes.NewBufferString(solution))
	if err != nil {
		return fmt.Errorf("failed to send the POST request to the URL %s . Error: %q", quesURL, err)
	}
	if resp.StatusCode < 200 || resp.StatusCode > 299 {
		if resp.StatusCode == 406 {
			return types.ErrorValidation{Reason: "not a valid answer to the question"}
		}
		return fmt.Errorf("got an error response status code. Status: %s", resp.Status)
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read the response body. Error: %q", err)
	}
	logrus.Debugf("got the response %s", string(respBodyBytes))
	return nil
}

// NewFileSystem returns a new IFileSystem object which manages workspaces and projects in the filesystem
func NewFileSystem() *FileSystem {
	fileSystem := &FileSystem{}
	workspaces, err := fileSystem.ListWorkspaces(nil)
	if err != nil {
		logrus.Fatalf("failed to list the workspaces. Error: %q", err)
	}
	for _, workspace := range workspaces {
		projects, err := fileSystem.ListProjects(workspace.Id)
		if err != nil {
			logrus.Fatalf("failed to list the projects in the workspace with id: %s . Error: %q", workspace.Id, err)
		}
		for _, project := range projects {
			for _, projOutput := range project.Outputs {
				if err := fileSystem.ResumeTransformation(workspace.Id, project.Id, projOutput.Id, false); err != nil {
					logrus.Debugf("failed to resume the transformation for output with id: %s of project id: %s . Error: %q", projOutput.Id, project.Id, err)
				}
			}
		}
	}
	return fileSystem
}

// Utility functions
func isVerbose() bool {
	return common.Config.LogLevel == logrus.TraceLevel.String() || common.Config.LogLevel == logrus.DebugLevel.String()
}

func validateAndProcessPlan(plan string, shouldProcess bool) (string, error) {
	// TODO: better validation of the plan
	p := map[string]interface{}{}
	if err := yaml.Unmarshal([]byte(plan), &p); err != nil {
		return "", fmt.Errorf("failed to unmarshal the plan as yaml. Error: %q", err)
	}
	if pApiVerI, ok := p["apiVersion"]; !ok {
		return "", fmt.Errorf("'apiVersion' is missing from the plan")
	} else if pApiVer, ok := pApiVerI.(string); !ok {
		return "", fmt.Errorf("'apiVersion' is not a string. Actual value is %+v of type %T", pApiVerI, pApiVerI)
	} else if !common.IsStringPresent(common.KNOWN_API_VERSIONS, pApiVer) {
		return "", fmt.Errorf("'apiVersion' is invalid. Expected one of %+v . Actual: %s", common.KNOWN_API_VERSIONS, pApiVer)
	} else if pKindI, ok := p["kind"]; !ok {
		return "", fmt.Errorf("'kind' is missing from the plan")
	} else if pKind, ok := pKindI.(string); !ok {
		return "", fmt.Errorf("'kind' is not a string. Actual value is %+v of type %T", pKindI, pKindI)
	} else if pKind != "Plan" {
		return "", fmt.Errorf("'kind' is invalid. Expected 'Plan' . Actual: %s", pKind)
	} else if pMetaI, ok := p["metadata"]; !ok {
		return "", fmt.Errorf("'metadata' is missing from the plan")
	} else if pMeta, ok := pMetaI.(map[string]interface{}); !ok {
		return "", fmt.Errorf("'metadata' is not a map[string]interface{} . Actual value is %+v of type %T", pMetaI, pMetaI)
	} else if pMetaNameI, ok := pMeta["name"]; !ok {
		return "", fmt.Errorf("'metadata.name' is missing from the plan")
	} else if pMetaName, ok := pMetaNameI.(string); !ok {
		return "", fmt.Errorf("'metadata.name' is not a string. Actual value is %+v of type %T", pMetaNameI, pMetaNameI)
	} else if _, err := common.NormalizeName(pMetaName); err != nil {
		return "", fmt.Errorf("'metadata.name' is invalid. failed to normalize the name. Error: %q", err)
	} else if pSpecI, ok := p["spec"]; !ok {
		return "", fmt.Errorf("'spec' is missing from the plan")
	} else if pSpec, ok := pSpecI.(map[string]interface{}); !ok {
		return "", fmt.Errorf("'spec' is not a map[string]interface{} . Actual value is %+v of type %T", pSpecI, pSpecI)
	} else if pSpecRootDirI, ok := pSpec["rootDir"]; !ok {
		return "", fmt.Errorf("'spec.rootDir' is missing from the plan")
	} else if pSpecRootDir, ok := pSpecRootDirI.(string); !ok {
		return "", fmt.Errorf("'spec.rootDir' is not a string. Actual value is %+v of type %T", pSpecRootDirI, pSpecRootDirI)
	} else if pSpecRootDir != SOURCES_DIR {
		return "", fmt.Errorf("'spec.rootDir' is invalid. Expected 'source' . Actual: %s", pSpecRootDir)
	} else {
		// TODO: better processing of the plan
		pMeta["name"], _ = common.NormalizeName(pMetaName)
	}
	return plan, nil
}

func (fs *FileSystem) runPlan(currentRunDir string, currentRunConfigPaths []string, currentRunSrcDir, currentRunCustDir, currentRunOutDir, message string, port int, workspaceId, projectId string, debugMode bool) error {
	logrus.Infof("Starting plan at directory %s using configs %+v and source %s and customizations %s to output %s", currentRunDir, currentRunConfigPaths, currentRunSrcDir, currentRunCustDir, currentRunOutDir)
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return err
	}
	normName, err := common.NormalizeName(project.Name)
	if err != nil {
		return types.ErrorValidation{Reason: fmt.Sprintf("failed to normalize the project name %s . Error: %q", project.Name, err)}
	}
	cmdArgs := []string{"plan", "--name", normName, "--source", currentRunSrcDir, "--plan-progress-port", cast.ToString(port), "--log-file", M2K_CLI_LOG_FILE}
	verbose := debugMode || isVerbose()
	if verbose {
		cmdArgs = append(cmdArgs, "--log-level", "trace")
	}
	for _, p := range currentRunConfigPaths {
		cmdArgs = append(cmdArgs, "--config", p)
	}
	if currentRunCustDir != "" {
		cmdArgs = append(cmdArgs, "--customizations", currentRunCustDir)
	}
	logrus.Infof("plan cmdArgs: %+v", cmdArgs)
	cmd := exec.Command(common.APP_NAME, cmdArgs...)
	cmd.Dir = currentRunDir
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		logrus.Errorf("failed to get the stdout pipe for the plan command. Error: %q", err)
		return err
	}
	stderr, err := cmd.StderrPipe()
	if err != nil {
		logrus.Errorf("failed to get the stderr pipe for the plan command. Error: %q", err)
		return err
	}
	if err := cmd.Start(); err != nil {
		logrus.Errorf("failed to start the plan command. Error: %q", err)
		return err
	}
	outCh := make(chan string, 10)
	stdoutReader := bufio.NewReader(stdout)
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		text, err := stdoutReader.ReadString('\n')
		for err == nil {
			updatedText := strings.TrimSpace(TIMESTAMP_REGEXP.ReplaceAllLiteralString(text, message))
			if updatedText != "" {
				outCh <- updatedText
			}
			text, err = stdoutReader.ReadString('\n')
		}
		logrus.Debugf("failed to fetch the stdout of move2kube plan. Error: %q", err)
		wg.Done()
	}()
	stderrReader := bufio.NewReader(stderr)
	wg.Add(1)
	go func() {
		text, err := stderrReader.ReadString('\n')
		for err == nil {
			updatedText := strings.TrimSpace(TIMESTAMP_REGEXP.ReplaceAllLiteralString(text, message))
			if updatedText != "" {
				outCh <- updatedText
			}
			text, err = stderrReader.ReadString('\n')
		}
		logrus.Debugf("failed to fetch the stderr of move2kube plan. Error: %q", err)
		wg.Done()
	}()
	go func() {
		wg.Wait()
		close(outCh)
	}()
	for outputLine := range outCh {
		if verbose {
			generateVerboseLogs(outputLine)
		} else {
			logrus.Info(outputLine)
		}
	}
	// release lock
	project, err = fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return err
	}
	project.Status[types.ProjectStatusPlanning] = false
	project.Status[types.ProjectStatusPlan] = true
	if err := fs.UpdateProject(workspaceId, project); err != nil {
		return fmt.Errorf("failed to update the project to unlock the plan generation. Error: %q", err)
	}
	return nil
}

func (fs *FileSystem) runTransform(currentRunDir string, currentRunConfigPaths []string, currentRunSrcDir, currentRunCustDir, currentRunOutDir, message string, port int, transformCh chan error, workspaceId, projectId string, projOutput types.ProjectOutput, debugMode bool) error {
	logrus.Infof("Starting transformation in %s with configs from %+v and source from %s , customizations from %s and output to %s", currentRunDir, currentRunConfigPaths, currentRunSrcDir, currentRunCustDir, currentRunOutDir)
	portStr, err := cast.ToStringE(port)
	if err != nil {
		return fmt.Errorf("failed to convert the port '%d' to a string. Error: %q", port, err)
	}
	cmdArgs := []string{"transform", "--qa-disable-cli", "--qa-port", portStr, "--source", currentRunSrcDir, "--output", currentRunOutDir, "--log-file", M2K_CLI_LOG_FILE}
	verbose := debugMode || isVerbose()
	if verbose {
		cmdArgs = append(cmdArgs, "--log-level", "trace")
	}
	if currentRunCustDir != "" {
		cmdArgs = append(cmdArgs, "--customizations", currentRunCustDir)
	}
	for _, p := range currentRunConfigPaths {
		cmdArgs = append(cmdArgs, "--config", p)
	}
	logrus.Infof("transform cmdArgs: %+v", cmdArgs)
	cmd := exec.Command(common.APP_NAME, cmdArgs...)
	cmd.Dir = currentRunDir
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		logrus.Errorf("failed to get the stdout pipe for the transform command. Error: %q", err)
		return err
	}
	stderr, err := cmd.StderrPipe()
	if err != nil {
		logrus.Errorf("failed to get the stderr pipe for the transform command. Error: %q", err)
		return err
	}
	if err := cmd.Start(); err != nil {
		logrus.Errorf("failed to start the transform command. Error: %q", err)
		return err
	}
	wg := sync.WaitGroup{}
	outCh := make(chan string, 10)
	stdoutReader := bufio.NewReader(stdout)
	wg.Add(1)
	go func() {
		text, err := stdoutReader.ReadString('\n')
		for err == nil {
			updatedText := strings.TrimSpace(TIMESTAMP_REGEXP.ReplaceAllLiteralString(text, message))
			if updatedText != "" {
				outCh <- updatedText
			}
			text, err = stdoutReader.ReadString('\n')
		}
		logrus.Debugf("failed to fetch the stdout of move2kube transform. Error: %q", err)
		wg.Done()
	}()
	stderrReader := bufio.NewReader(stderr)
	wg.Add(1)
	go func() {
		text, err := stderrReader.ReadString('\n')
		for err == nil {
			updatedText := strings.TrimSpace(TIMESTAMP_REGEXP.ReplaceAllLiteralString(text, message))
			if updatedText != "" {
				outCh <- updatedText
			}
			text, err = stderrReader.ReadString('\n')
		}
		logrus.Debugf("failed to fetch the stderr of move2kube transform. Error: %q", err)
		wg.Done()
	}()
	go func() {
		wg.Wait()
		close(outCh)
	}()
	flag := true
	for outputLine := range outCh {
		if flag && strings.Contains(outputLine, portStr) {
			flag = false
			transformCh <- nil
			close(transformCh)
		}
		if verbose {
			generateVerboseLogs(outputLine)
		} else {
			logrus.Info(outputLine)
		}
	}
	// create the output zip file
	if err := copyOverPlanConfigAndQACache(currentRunDir, currentRunOutDir); err != nil {
		logrus.Errorf("failed to copy over the m2kconfig.yaml and m2kqacache.yaml. Error: %q", err)
	}
	zipPath := filepath.Join(currentRunDir, "output.zip")
	if err := archiver.NewZip().Archive([]string{currentRunOutDir}, zipPath); err != nil {
		return fmt.Errorf("failed to create the output zip file at path %s using the output directory at path %s . Error: %q", zipPath, currentRunOutDir, err)
	}
	// indicate that the transformation is done
	project, err := fs.ReadProject(workspaceId, projectId)
	if err != nil {
		return fmt.Errorf("failed to read the project with id %s to update the status of the output %+v . Error: %q", projectId, projOutput, err)
	}
	po := project.Outputs[projOutput.Id]
	po.Status = types.ProjectOutputStatusDone
	project.Outputs[projOutput.Id] = po
	if err := fs.UpdateProject(workspaceId, project); err != nil {
		return fmt.Errorf("failed to update the project to finish the transformation. Error: %q", err)
	}
	if common.Config.CleanUpAfterTransform {
		if err := cleanUpAfterTransform(currentRunDir); err != nil {
			logrus.Errorf("failed to clean up after transformation finished. Error: %q", err)
		}
	}
	return nil
}

func cleanUpAfterTransform(currentRunDir string) error {
	sourcesPath := filepath.Join(currentRunDir, SOURCES_DIR)
	if err := os.RemoveAll(sourcesPath); err != nil {
		return fmt.Errorf("failed to clean up the sources directory at path %s . Error: %q", sourcesPath, err)
	}
	custsPath := filepath.Join(currentRunDir, CUSTOMIZATIONS_DIR)
	if err := os.RemoveAll(custsPath); err != nil {
		return fmt.Errorf("failed to clean up the customizations directory at path %s . Error: %q", custsPath, err)
	}
	configsPath := filepath.Join(currentRunDir, CONFIGS_DIR)
	if err := os.RemoveAll(configsPath); err != nil {
		return fmt.Errorf("failed to clean up the configs directory at path %s . Error: %q", configsPath, err)
	}
	return nil
}

func copyOverPlanConfigAndQACache(srcDir, destDir string) error {
	planSrcPath := filepath.Join(srcDir, "m2k.plan")
	configSrcPath := filepath.Join(srcDir, "m2kconfig.yaml")
	qaCacheSrcPath := filepath.Join(srcDir, "m2kqacache.yaml")
	planDestPath := filepath.Join(destDir, "m2k.plan")
	configDestPath := filepath.Join(destDir, "m2kconfig.yaml")
	qaCacheDestPath := filepath.Join(destDir, "m2kqacache.yaml")
	planBytes, err := os.ReadFile(planSrcPath)
	if err != nil {
		return fmt.Errorf("failed to read the plan file at path %s . Error: %q", planSrcPath, err)
	}
	if err := ioutil.WriteFile(planDestPath, planBytes, DEFAULT_FILE_PERMISSIONS); err != nil {
		return fmt.Errorf("failed to write the plan file to the path %s . Error: %q", planDestPath, err)
	}
	configBytes, err := os.ReadFile(configSrcPath)
	if err != nil {
		return fmt.Errorf("failed to read the config file at path %s . Error: %q", configSrcPath, err)
	}
	if err := ioutil.WriteFile(configDestPath, configBytes, DEFAULT_FILE_PERMISSIONS); err != nil {
		return fmt.Errorf("failed to write the config file to the path %s . Error: %q", configDestPath, err)
	}
	qaCacheBytes, err := os.ReadFile(qaCacheSrcPath)
	if err != nil {
		return fmt.Errorf("failed to read the qa cache file at path %s . Error: %q", qaCacheSrcPath, err)
	}
	if err := ioutil.WriteFile(qaCacheDestPath, qaCacheBytes, DEFAULT_FILE_PERMISSIONS); err != nil {
		return fmt.Errorf("failed to write the qa cache file to the path %s . Error: %q", qaCacheDestPath, err)
	}
	return nil
}

// ReadJSON reads a json file into an object
func ReadJSON(path string, data interface{}) error {
	jsonBytes, err := ioutil.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return err
		}
		return fmt.Errorf("failed to read the json file at path %s . Error: %q", path, err)
	}
	if err := json.Unmarshal(jsonBytes, data); err != nil {
		return fmt.Errorf("failed to unmarshal the json into the object of type %T . Error: %q", data, err)
	}
	return nil
}

// WriteJSON reads a json file into an object
func WriteJSON(path string, data interface{}) error {
	jsonBytes, err := json.Marshal(data)
	if err != nil {
		return fmt.Errorf("failed to marshal the object of type %T to json. Error: %q", data, err)
	}
	if err := ioutil.WriteFile(path, jsonBytes, DEFAULT_FILE_PERMISSIONS); err != nil {
		return fmt.Errorf("failed to write the json to a file at path %s . Error: %q", path, err)
	}
	return nil
}

func getDNSHostName() string {
	logrus.Trace("getDNSHostName start")
	dnsHostName := ""
	ifaces, err := net.Interfaces()
	if err != nil {
		logrus.Errorf("failed to get the interfaces. Error: %q", err)
		return ""
	}
	for _, iface := range ifaces {
		addrs, err := iface.Addrs()
		if err != nil {
			logrus.Errorf("failed to get the addresses for the interface %s . Error: %q", iface.Name, err)
			continue
		}
		for _, addr := range addrs {
			var ip net.IP
			switch v := addr.(type) {
			case *net.IPNet:
				ip = v.IP
			case *net.IPAddr:
				ip = v.IP
			}
			ptr, err := net.LookupAddr(ip.String())
			if err != nil {
				logrus.Errorf("failed to do a reverse lookup for the address %s . Error: %q", addr.String(), err)
				continue
			}
			for _, ptrvalue := range ptr {
				logrus.Debugf("host: %s", ptrvalue)
				if len(dnsHostName) <= len(ptrvalue) {
					dnsHostName = ptrvalue
				}
			}
		}
	}
	logrus.Debugf("dnsHostName: '%s'", dnsHostName)
	logrus.Trace("getDNSHostName end")
	return dnsHostName
}

// generateVerboseLogs synchronizes move2kube-api loggging level wrt move2kube logging level
func generateVerboseLogs(message string) {
	var loggingLevel string
	sm := LOG_LEVEL_REGEXP.FindStringSubmatch(message)
	if len(sm) > 1 {
		loggingLevel = sm[1]
	} else {
		loggingLevel = "info"
	}
	syncLoggingLevel(loggingLevel, message)
}

//syncLoggingLevel matches log levels of Move2Kube-api and Move2Kube
func syncLoggingLevel(loggingLevel, message string) {
	switch {
	case loggingLevel == "trace":
		logrus.Trace(message)
	case loggingLevel == "debug":
		logrus.Debug(message)
	case loggingLevel == "info":
		logrus.Info(message)
	case loggingLevel == "warning":
		logrus.Warn(message)
	case loggingLevel == "error":
		logrus.Error(message)
	case loggingLevel == "fatal":
		logrus.Error(message)
	case loggingLevel == "panic":
		logrus.Error(message)
	default:
		logrus.Info(message)
	}
}

// putM2KIgnore writes a .m2kignore file to a directory that ignores the contents of that directory.
// NOTE: It will not ignore subdirectories. if the directory does not exist it will be created.
func putM2KIgnore(path string) error {
	if err := os.MkdirAll(path, DEFAULT_DIRECTORY_PERMISSIONS); err != nil {
		return fmt.Errorf("failed to create a directory at the path %s . Error: %q", path, err)
	}
	m2kIgnorePath := filepath.Join(path, ".m2kignore")
	if err := ioutil.WriteFile(m2kIgnorePath, []byte("."), DEFAULT_FILE_PERMISSIONS); err != nil {
		return fmt.Errorf("failed to write a .m2kingore file to the path %s . Error: %q", m2kIgnorePath, err)
	}
	return nil
}

func copyDir(src, dest string) error {
	cmd := exec.Command("cp", "-r", src, dest)
	return cmd.Run()
}

func checkErr(err error) {
	logrus.Trace("checkErr start")
	if err == nil {
		logrus.Debug("Ok")
		return
	} else if netError, ok := err.(net.Error); ok {
		logrus.Debugf("net.Error: %q", netError)
		if netError.Timeout() {
			logrus.Debug("Timeout")
			return
		}
	}
	switch t := err.(type) {
	case *net.OpError:
		if t.Op == "dial" {
			logrus.Debug("Unknown host")
		} else if t.Op == "read" {
			logrus.Debug("Connection refused")
		} else {
			logrus.Debugf("*net.OpError t.Op %+v", t.Op)
		}
	case syscall.Errno:
		if t == syscall.ECONNREFUSED {
			logrus.Debug("Connection refused")
		} else {
			logrus.Debugf("syscall.Errno t %+v", t)
		}
	default:
		logrus.Debugf("default %T %+v", t, t)
	}
	logrus.Trace("checkErr end")
}

func getConfigPaths(configsDir string, project types.Project) ([]string, error) {
	configPaths := []string{}
	times := []int64{}
	for _, inp := range project.Inputs {
		if inp.Type != types.ProjectInputConfigs {
			continue
		}
		t, err := time.Parse(time.RFC3339, inp.Timestamp)
		if err != nil {
			continue
		}
		times = append(times, t.Unix())
		configPaths = append(configPaths, filepath.Join(configsDir, inp.NormalizedName))
	}
	sort.Sort(mySortable{ids: configPaths, times: times})
	return configPaths, nil
}

// mySortable implements the sort.Interface
type mySortable struct {
	ids   []string
	times []int64
}

func (s mySortable) Len() int {
	return len(s.ids)
}

func (s mySortable) Less(i, j int) bool {
	return s.times[i] < s.times[j]
}

func (s mySortable) Swap(i, j int) {
	s.times[i], s.times[j] = s.times[j], s.times[i]
	s.ids[i], s.ids[j] = s.ids[j], s.ids[i]
}
